/**
 * Autogenerated by Thrift Compiler (0.7.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package imaging {

import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


  public class ImagingProcessor implements TProcessor {
    public function ImagingProcessor(iface:Imaging)
    {
      iface_ = iface;
      PROCESS_MAP["mandelbrot"] = mandelbrot();
      PROCESS_MAP["transform"] = transform();
    }

    private var iface_:Imaging;
    protected const PROCESS_MAP:Dictionary = new Dictionary();

    public function process(iprot:TProtocol, oprot:TProtocol):Boolean
    {
      var msg:TMessage = iprot.readMessageBegin();
      var fn:Function = PROCESS_MAP[msg.name];
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        var x:TApplicationError = new TApplicationError(TApplicationError.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.call(this,msg.seqid, iprot, oprot);
      return true;
    }

    private function mandelbrot():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:mandelbrot_args = new mandelbrot_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:mandelbrot_result = new mandelbrot_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (ouch:InvalidOperation) {
          result.ouch = ouch;
        } catch (th:Error) {
          trace("Internal error processing mandelbrot", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing mandelbrot");
          oprot.writeMessageBegin(new TMessage("mandelbrot", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("mandelbrot", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function transform():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:transform_args = new transform_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:transform_result = new transform_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (ouch:InvalidOperation) {
          result.ouch = ouch;
        } catch (th:Error) {
          trace("Internal error processing transform", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing transform");
          oprot.writeMessageBegin(new TMessage("transform", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("transform", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

}
import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


import imaging.*;
class mandelbrot_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("mandelbrot_args");
  private static const W_FIELD_DESC:TField = new TField("w", TType.I32, 1);
  private static const H_FIELD_DESC:TField = new TField("h", TType.I32, 2);

  private var _w:int;
  public static const W:int = 1;
  private var _h:int;
  public static const H:int = 2;

  private var __isset_w:Boolean = false;
  private var __isset_h:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[W] = new FieldMetaData("w", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[H] = new FieldMetaData("h", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
  }
  {
    FieldMetaData.addStructMetaDataMap(mandelbrot_args, metaDataMap);
  }

  public function mandelbrot_args() {
  }

  public function get w():int {
    return this._w;
  }

  public function set w(w:int):void {
    this._w = w;
    this.__isset_w = true;
  }

  public function unsetW():void {
    this.__isset_w = false;
  }

  // Returns true if field w is set (has been assigned a value) and false otherwise
  public function isSetW():Boolean {
    return this.__isset_w;
  }

  public function get h():int {
    return this._h;
  }

  public function set h(h:int):void {
    this._h = h;
    this.__isset_h = true;
  }

  public function unsetH():void {
    this.__isset_h = false;
  }

  // Returns true if field h is set (has been assigned a value) and false otherwise
  public function isSetH():Boolean {
    return this.__isset_h;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case W:
      if (value == null) {
        unsetW();
      } else {
        this.w = value;
      }
      break;

    case H:
      if (value == null) {
        unsetH();
      } else {
        this.h = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case W:
      return this.w;
    case H:
      return this.h;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case W:
      return isSetW();
    case H:
      return isSetH();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case W:
          if (field.type == TType.I32) {
            this.w = iprot.readI32();
            this.__isset_w = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case H:
          if (field.type == TType.I32) {
            this.h = iprot.readI32();
            this.__isset_h = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldBegin(W_FIELD_DESC);
    oprot.writeI32(this.w);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(H_FIELD_DESC);
    oprot.writeI32(this.h);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("mandelbrot_args(");
    var first:Boolean = true;

    ret += "w:";
    ret += this.w;
    first = false;
    if (!first) ret +=  ", ";
    ret += "h:";
    ret += this.h;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class mandelbrot_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("mandelbrot_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const OUCH_FIELD_DESC:TField = new TField("ouch", TType.STRUCT, 1);

  private var _success:ByteArray;
  public static const SUCCESS:int = 0;
  private var _ouch:InvalidOperation;
  public static const OUCH:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[OUCH] = new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(mandelbrot_result, metaDataMap);
  }

  public function mandelbrot_result() {
  }

  public function get success():ByteArray {
    return this._success;
  }

  public function set success(success:ByteArray):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get ouch():InvalidOperation {
    return this._ouch;
  }

  public function set ouch(ouch:InvalidOperation):void {
    this._ouch = ouch;
  }

  public function unsetOuch():void {
    this.ouch = null;
  }

  // Returns true if field ouch is set (has been assigned a value) and false otherwise
  public function isSetOuch():Boolean {
    return this.ouch != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case OUCH:
      if (value == null) {
        unsetOuch();
      } else {
        this.ouch = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case OUCH:
      return this.ouch;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case OUCH:
      return isSetOuch();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OUCH:
          if (field.type == TType.STRUCT) {
            this.ouch = new InvalidOperation();
            this.ouch.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetOuch()) {
      oprot.writeFieldBegin(OUCH_FIELD_DESC);
      this.ouch.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("mandelbrot_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "ouch:";
    if (this.ouch == null) {
      ret += "null";
    } else {
      ret += this.ouch;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class transform_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("transform_args");
  private static const T_FIELD_DESC:TField = new TField("t", TType.I32, 1);
  private static const IMG_FIELD_DESC:TField = new TField("img", TType.STRING, 2);

  private var _t:int;
  public static const T:int = 1;
  private var _img:ByteArray;
  public static const IMG:int = 2;

  private var __isset_t:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[T] = new FieldMetaData("t", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[IMG] = new FieldMetaData("img", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(transform_args, metaDataMap);
  }

  public function transform_args() {
  }

  public function get t():int {
    return this._t;
  }

  public function set t(t:int):void {
    this._t = t;
    this.__isset_t = true;
  }

  public function unsetT():void {
    this.__isset_t = false;
  }

  // Returns true if field t is set (has been assigned a value) and false otherwise
  public function isSetT():Boolean {
    return this.__isset_t;
  }

  public function get img():ByteArray {
    return this._img;
  }

  public function set img(img:ByteArray):void {
    this._img = img;
  }

  public function unsetImg():void {
    this.img = null;
  }

  // Returns true if field img is set (has been assigned a value) and false otherwise
  public function isSetImg():Boolean {
    return this.img != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case T:
      if (value == null) {
        unsetT();
      } else {
        this.t = value;
      }
      break;

    case IMG:
      if (value == null) {
        unsetImg();
      } else {
        this.img = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case T:
      return this.t;
    case IMG:
      return this.img;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case T:
      return isSetT();
    case IMG:
      return isSetImg();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case T:
          if (field.type == TType.I32) {
            this.t = iprot.readI32();
            this.__isset_t = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IMG:
          if (field.type == TType.STRING) {
            this.img = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldBegin(T_FIELD_DESC);
    oprot.writeI32(this.t);
    oprot.writeFieldEnd();
    if (this.img != null) {
      oprot.writeFieldBegin(IMG_FIELD_DESC);
      oprot.writeBinary(this.img);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("transform_args(");
    var first:Boolean = true;

    ret += "t:";
    var t_name:String = Transform.VALUES_TO_NAMES[this.t];
    if (t_name != null) {
      ret += t_name;
      ret += " (";
    }
    ret += this.t;
    if (t_name != null) {
      ret += ")";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "img:";
    if (this.img == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetT() && !Transform.VALID_VALUES.contains(t)){
      throw new TProtocolError(TProtocolError.UNKNOWN, "The field 't' has been assigned the invalid value " + t);
    }
  }

}

class transform_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("transform_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const OUCH_FIELD_DESC:TField = new TField("ouch", TType.STRUCT, 1);

  private var _success:ByteArray;
  public static const SUCCESS:int = 0;
  private var _ouch:InvalidOperation;
  public static const OUCH:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[OUCH] = new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(transform_result, metaDataMap);
  }

  public function transform_result() {
  }

  public function get success():ByteArray {
    return this._success;
  }

  public function set success(success:ByteArray):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get ouch():InvalidOperation {
    return this._ouch;
  }

  public function set ouch(ouch:InvalidOperation):void {
    this._ouch = ouch;
  }

  public function unsetOuch():void {
    this.ouch = null;
  }

  // Returns true if field ouch is set (has been assigned a value) and false otherwise
  public function isSetOuch():Boolean {
    return this.ouch != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case OUCH:
      if (value == null) {
        unsetOuch();
      } else {
        this.ouch = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case OUCH:
      return this.ouch;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case OUCH:
      return isSetOuch();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OUCH:
          if (field.type == TType.STRUCT) {
            this.ouch = new InvalidOperation();
            this.ouch.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetOuch()) {
      oprot.writeFieldBegin(OUCH_FIELD_DESC);
      this.ouch.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("transform_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "ouch:";
    if (this.ouch == null) {
      ret += "null";
    } else {
      ret += this.ouch;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

